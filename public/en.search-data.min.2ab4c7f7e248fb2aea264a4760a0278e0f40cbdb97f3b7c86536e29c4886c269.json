[{"id":0,"href":"/circuit_breaker/docs/overview/","title":"Overview","section":"Docs","content":" Overview # Motivation # Circuit Breaker was created to address the growing need for robust, AI-powered workflow management in modern applications. As applications increasingly incorporate AI capabilities, there\u0026rsquo;s a need for a framework that can:\nSeamlessly Integrate AI: Handle interactions with various LLM providers while maintaining clean separation of concerns Manage Complex Workflows: Provide a declarative way to define and manage state transitions with validation Ensure Reliability: Implement proper error handling, retries, and state management for AI operations Maintain Flexibility: Allow for custom executors and easy extension of functionality Architecture # Circuit Breaker uses a hybrid architecture combining several powerful concepts:\n1. Workflow Engine # The core workflow engine is based on Petri nets, providing:\nFormal verification capabilities Clear state management Transition validation Comprehensive event tracking While basic Petri nets are not Turing complete, our implementation is closer to Colored Petri Nets (CPNs) or High-level Petri Nets, balancing theoretical power with practical utility.\n2. Rules Engine # A unified system for managing:\nValidation rules Transition policies Business logic Error handling The rules engine provides:\nDeclarative rule definitions Complex rule chains Clear error reporting Rule reusability 3. AI Integration Layer # A flexible system for:\nMultiple LLM provider support Automatic model selection Tool integration Memory management Error handling with retries 4. Event System # Comprehensive tracking and auditing:\nState transition history Action execution logs Error tracking Audit trails Design Philosophy # Circuit Breaker balances several key principles:\nTheoretical Soundness: Using formal methods (Petri nets) for workflow verification Practical Utility: Providing a clean, Ruby-like DSL for easy implementation Flexibility: Supporting custom executors and extensions Reliability: Implementing robust error handling and state management This design allows Circuit Breaker to be:\nExpressive enough for complex business processes Analyzable for critical property verification Maintainable through the workflow DSL Extensible for various use cases "},{"id":1,"href":"/circuit_breaker/docs/getting-started/","title":"Getting Started","section":"Docs","content":" Getting Started with Circuit Breaker # Installation # Add this line to your application\u0026rsquo;s Gemfile:\ngem \u0026#39;circuit_breaker\u0026#39; And then execute:\n$ bundle install Or install it yourself as:\n$ gem install circuit_breaker Basic Usage # Action-Rule Data Flow # Circuit Breaker provides a powerful mechanism for passing data between actions and rules during workflow transitions. Here\u0026rsquo;s how it works:\nActions with Named Results flow :draft \u0026gt;\u0026gt; :pending_review, :submit do actions do # Execute action and store result with key :clarity execute analyzer, :analyze_clarity, :clarity end policy all: [:valid_clarity] end Accessing Results in Rules CircuitBreaker::Rules::DSL.define do rule :valid_clarity do |token| # Retrieve stored result using the same key clarity = context.get_result(:clarity) clarity \u0026amp;\u0026amp; clarity[:score] \u0026gt;= 70 end end Data Flow Process # Actions are executed first during a transition Results are stored in an action context using the specified key Rules can access these results through the same key This enables rules to validate based on action outputs This pattern allows for:\nClean separation between action execution and rule validation Reusable actions with different validation rules Complex rule chains based on multiple action results Clear data flow tracking during transitions "},{"id":2,"href":"/circuit_breaker/docs/executors/","title":"Executors","section":"Docs","content":" Circuit Breaker Executors # The Circuit Breaker executor system provides a flexible, DSL-driven approach to defining and running various types of execution environments. Each executor follows a consistent pattern while allowing for specialized configuration and behavior.\nExecutor DSL # The executor DSL provides a declarative way to define:\nRequired and optional parameters Type validations Custom validation rules Execution lifecycle hooks Basic Structure # class MyExecutor \u0026lt; BaseExecutor executor_config do # Parameter definitions parameter :name, type: :string, required: true, description: \u0026#39;Description of the parameter\u0026#39; # Validation rules validate do |context| # Custom validation logic end # Lifecycle hooks before_execute do |context| # Setup logic end after_execute do |result| # Cleanup or logging logic end end protected def execute_internal # Implementation @result = { status: \u0026#39;completed\u0026#39; } end end Parameter Types # The DSL supports the following parameter types:\n:string :integer :array :hash :boolean Each parameter can be configured with:\nrequired: true/false - Whether the parameter must be provided default: value - Default value if not provided description: 'text' - Documentation for the parameter Available Executors # Docker Executor # Runs containers with configurable images, commands, and environment.\ndocker = DockerExecutor.new( image: \u0026#39;nginx:latest\u0026#39;, command: \u0026#39;nginx -g \u0026#34;daemon off;\u0026#34;\u0026#39;, environment: { \u0026#39;PORT\u0026#39; =\u0026gt; \u0026#39;8080\u0026#39; }, volumes: [\u0026#39;/host/path:/container/path\u0026#39;] ) result = docker.execute NATS Executor # Manages workflow state and event distribution using NATS.\nnats = NatsExecutor.new( nats_url: \u0026#39;nats://localhost:4222\u0026#39;, petri_net: workflow_definition, workflow_id: \u0026#39;custom-id\u0026#39; ) result = nats.execute Assistant Executor # Interacts with AI assistants for natural language processing tasks.\nassistant = CircuitBreaker::Executors::AssistantExecutor.define do use_model \u0026#39;qwen2.5-coder\u0026#39; with_system_prompt \u0026#34;You are a specialized assistant...\u0026#34; with_parameters temperature: 0.7, top_p: 0.9 add_tools [AnalysisTool.new, SentimentTool.new] end "},{"id":3,"href":"/circuit_breaker/docs/examples/","title":"Examples","section":"Docs","content":" Document Workflow Example # This example demonstrates how to use Circuit Breaker to implement a document workflow system with AI-powered analysis. It showcases a declarative DSL for defining workflows, rules, validations, and AI-powered document analysis.\nWorkflow Overview # The document workflow system implements a document review and approval process with the following states:\ndraft: Initial state for new documents pending_review: Document submitted for review reviewed: Review completed with comments approved: Document approved by manager rejected: Document rejected with reasons Key Features # 1. Unified Rules System # Declarative rule definitions using DSL Complex rule chains with AND/OR logic Built-in validation helpers Clear error reporting Rule reusability across transitions 2. Workflow Management # Intuitive state transition syntax (from \u0026gt;\u0026gt; to) Policy-based transitions with rule chains Comprehensive history tracking Event handling and state management Automatic validation during transitions 3. Document Rules # Document validation rules: valid_reviewer: Ensures reviewer is assigned valid_review: Validates review comments valid_approver: Checks approver assignment is_admin_approver: Verifies approver permissions valid_word_count: Checks document length valid_external_url: Validates external references 4. AI-Powered Document Analysis # Content quality and structure assessment Sentiment and tone analysis Automatic context detection Improvement suggestions Word count validation Implementation # 1. Define Document Rules # rules = DocumentRules.define do rule :valid_reviewer do |token| token.reviewer_id.present? end rule :valid_review do |token| token.reviewer_comments.present? end rule :is_admin_approver do |token| token.approver_id\u0026amp;.start_with?(\u0026#39;admin_\u0026#39;) end end 2. Create Workflow # workflow = CircuitBreaker::WorkflowDSL.define(rules: rules) do states :draft, :pending_review, :reviewed, :approved, :rejected flow(:draft \u0026gt;\u0026gt; :pending_review) .transition(:submit) .policy(rules: { all: [:valid_reviewer] }) flow(:pending_review \u0026gt;\u0026gt; :reviewed) .transition(:review) .policy( rules: { all: [:valid_review], any: [:is_high_priority, :is_urgent] } ) flow(:reviewed \u0026gt;\u0026gt; :approved) .transition(:approve) .policy( rules: { all: [:valid_approver, :valid_review, :is_admin_approver], any: [:valid_external_url, :valid_word_count] } ) end 3. Process Document # # Create document token = Examples::DocumentToken.new( title: \u0026#34;Project Proposal\u0026#34;, reviewer_id: \u0026#34;user_123\u0026#34;, reviewer_comments: \u0026#34;Looks good, minor revisions needed\u0026#34;, approver_id: \u0026#34;admin_456\u0026#34; ) # Initialize workflow workflow = DocumentWorkflow.new(token) # Submit for review workflow.submit # Review document workflow.review # Approve document workflow.approve "}]