[{"id":0,"href":"/circuit_breaker/docs/overview/","title":"Overview","section":"Docs","content":" Overview # Motivation # Circuit Breaker was created to address the growing need for robust, AI-powered workflow management in modern applications. As applications increasingly incorporate AI capabilities, there\u0026rsquo;s a need for a framework that can:\nSeamlessly Integrate AI: Handle interactions with various LLM providers while maintaining clean separation of concerns Manage Complex Workflows: Provide a declarative way to define and manage state transitions with validation Ensure Reliability: Implement proper error handling, retries, and state management for AI operations Maintain Flexibility: Allow for custom executors and easy extension of functionality Architecture # Circuit Breaker uses a hybrid architecture combining several powerful concepts:\n1. Workflow Engine # The core workflow engine is based on Petri nets, providing:\nFormal verification capabilities Clear state management Transition validation Comprehensive event tracking While basic Petri nets are not Turing complete, our implementation is closer to Colored Petri Nets (CPNs) or High-level Petri Nets, balancing theoretical power with practical utility.\n2. Rules Engine # A unified system for managing:\nValidation rules Transition policies Business logic Error handling The rules engine provides:\nDeclarative rule definitions Complex rule chains Clear error reporting Rule reusability 3. AI Integration Layer # A flexible system for:\nMultiple LLM provider support Automatic model selection Tool integration Memory management Error handling with retries 4. Event System # Comprehensive tracking and auditing:\nState transition history Action execution logs Error tracking Audit trails Design Philosophy # Circuit Breaker balances several key principles:\nTheoretical Soundness: Using formal methods (Petri nets) for workflow verification Practical Utility: Providing a clean, Ruby-like DSL for easy implementation Flexibility: Supporting custom executors and extensions Reliability: Implementing robust error handling and state management This design allows Circuit Breaker to be:\nExpressive enough for complex business processes Analyzable for critical property verification Maintainable through the workflow DSL Extensible for various use cases "},{"id":1,"href":"/circuit_breaker/docs/getting-started/","title":"Getting Started","section":"Docs","content":" Getting Started with Circuit Breaker # Installation # Add this line to your application\u0026rsquo;s Gemfile:\ngem \u0026#39;circuit_breaker\u0026#39; And then execute:\n$ bundle install Or install it yourself as:\n$ gem install circuit_breaker Basic Usage # Action-Rule Data Flow # Circuit Breaker provides a powerful mechanism for passing data between actions and rules during workflow transitions. Here\u0026rsquo;s how it works:\nActions with Named Results flow :draft \u0026gt;\u0026gt; :pending_review, :submit do actions do # Execute action and store result with key :clarity execute analyzer, :analyze_clarity, :clarity end policy all: [:valid_clarity] end Accessing Results in Rules CircuitBreaker::Rules::DSL.define do rule :valid_clarity do |token| # Retrieve stored result using the same key clarity = context.get_result(:clarity) clarity \u0026amp;\u0026amp; clarity[:score] \u0026gt;= 70 end end Data Flow Process # Actions are executed first during a transition Results are stored in an action context using the specified key Rules can access these results through the same key This enables rules to validate based on action outputs This pattern allows for:\nClean separation between action execution and rule validation Reusable actions with different validation rules Complex rule chains based on multiple action results Clear data flow tracking during transitions "},{"id":2,"href":"/circuit_breaker/docs/executors/","title":"Executors","section":"Docs","content":" Circuit Breaker Executors # The Circuit Breaker executor system provides a flexible, DSL-driven approach to defining and running various types of execution environments. Each executor follows a consistent pattern while allowing for specialized configuration and behavior.\nExecutor DSL # The executor DSL provides a declarative way to define:\nRequired and optional parameters Type validations Custom validation rules Execution lifecycle hooks Basic Structure # class MyExecutor \u0026lt; BaseExecutor executor_config do # Parameter definitions parameter :name, type: :string, required: true, description: \u0026#39;Description of the parameter\u0026#39; # Validation rules validate do |context| # Custom validation logic end # Lifecycle hooks before_execute do |context| # Setup logic end after_execute do |result| # Cleanup or logging logic end end protected def execute_internal # Implementation @result = { status: \u0026#39;completed\u0026#39; } end end Parameter Types # The DSL supports the following parameter types:\n:string :integer :array :hash :boolean Each parameter can be configured with:\nrequired: true/false - Whether the parameter must be provided default: value - Default value if not provided description: 'text' - Documentation for the parameter Available Executors # Docker Executor # Runs containers with configurable images, commands, and environment.\ndocker = DockerExecutor.new( image: \u0026#39;nginx:latest\u0026#39;, command: \u0026#39;nginx -g \u0026#34;daemon off;\u0026#34;\u0026#39;, environment: { \u0026#39;PORT\u0026#39; =\u0026gt; \u0026#39;8080\u0026#39; }, volumes: [\u0026#39;/host/path:/container/path\u0026#39;] ) result = docker.execute NATS Executor # Manages workflow state and event distribution using NATS.\nnats = NatsExecutor.new( nats_url: \u0026#39;nats://localhost:4222\u0026#39;, petri_net: workflow_definition, workflow_id: \u0026#39;custom-id\u0026#39; ) result = nats.execute Assistant Executor # Interacts with AI assistants for natural language processing tasks.\nassistant = CircuitBreaker::Executors::AssistantExecutor.define do use_model \u0026#39;qwen2.5-coder\u0026#39; with_system_prompt \u0026#34;You are a specialized assistant...\u0026#34; with_parameters temperature: 0.7, top_p: 0.9 add_tools [AnalysisTool.new, SentimentTool.new] end "},{"id":3,"href":"/circuit_breaker/docs/examples/","title":"Examples","section":"Docs","content":" Document Workflow Example # This example demonstrates how to use Circuit Breaker to implement a document workflow system with AI-powered analysis. It showcases a declarative DSL for defining workflows, rules, validations, and AI-powered document analysis.\nWorkflow Overview # The document workflow system implements a document review and approval process with the following states:\ndraft: Initial state for new documents pending_review: Document submitted for review reviewed: Review completed with comments approved: Document approved by manager rejected: Document rejected with reasons Key Features # 1. Unified Rules System # Declarative rule definitions using DSL Complex rule chains with AND/OR logic Built-in validation helpers Clear error reporting Rule reusability across transitions 2. Workflow Management # Intuitive state transition syntax (from \u0026gt;\u0026gt; to) Policy-based transitions with rule chains Comprehensive history tracking Event handling and state management Automatic validation during transitions 3. Document Rules # Document validation rules: valid_reviewer: Ensures reviewer is assigned valid_review: Validates review comments valid_approver: Checks approver assignment is_admin_approver: Verifies approver permissions valid_word_count: Checks document length valid_external_url: Validates external references 4. AI-Powered Document Analysis # Content quality and structure assessment Sentiment and tone analysis Automatic context detection Improvement suggestions Word count validation Implementation # 1. Define Document Rules # rules = DocumentRules.define do rule :valid_reviewer do |token| token.reviewer_id.present? end rule :valid_review do |token| token.reviewer_comments.present? end rule :is_admin_approver do |token| token.approver_id\u0026amp;.start_with?(\u0026#39;admin_\u0026#39;) end end 2. Create Workflow # workflow = CircuitBreaker::WorkflowDSL.define(rules: rules) do states :draft, :pending_review, :reviewed, :approved, :rejected flow(:draft \u0026gt;\u0026gt; :pending_review) .transition(:submit) .policy(rules: { all: [:valid_reviewer] }) flow(:pending_review \u0026gt;\u0026gt; :reviewed) .transition(:review) .policy( rules: { all: [:valid_review], any: [:is_high_priority, :is_urgent] } ) flow(:reviewed \u0026gt;\u0026gt; :approved) .transition(:approve) .policy( rules: { all: [:valid_approver, :valid_review, :is_admin_approver], any: [:valid_external_url, :valid_word_count] } ) end 3. Process Document # # Create document token = Examples::DocumentToken.new( title: \u0026#34;Project Proposal\u0026#34;, reviewer_id: \u0026#34;user_123\u0026#34;, reviewer_comments: \u0026#34;Looks good, minor revisions needed\u0026#34;, approver_id: \u0026#34;admin_456\u0026#34; ) # Initialize workflow workflow = DocumentWorkflow.new(token) # Submit for review workflow.submit # Review document workflow.review # Approve document workflow.approve "},{"id":4,"href":"/circuit_breaker/docs/comparison/","title":"Comparison with Other Systems","section":"Docs","content":" Comparison with Other Systems # DAGs vs. Petri Nets # Directed Acyclic Graphs (DAGs) # DAGs are commonly used in workflow systems like Argo Workflows and Apache Airflow. They offer:\nAdvantages:\nSimple, intuitive representation of task dependencies Easy to visualize and understand Well-suited for linear, one-way processes Efficient execution of parallel tasks Limitations:\nCannot represent cycles or loops natively Limited ability to model complex state conditions No built-in concept of state or tokens Difficult to model complex business processes Petri Nets # Circuit Breaker uses Petri Nets (specifically, a variant closer to Colored Petri Nets) as its underlying model. This provides:\nAdvantages:\nRich theoretical foundation with formal verification Native support for state and tokens Ability to model complex conditions and cycles Better representation of business processes Support for concurrent and distributed systems Limitations:\nMore complex to understand initially Can be more verbose for simple linear workflows Requires more careful design for optimal performance Comparison with Argo Workflows # Focus: Container-native workflow engine for Kubernetes\nKey Differences:\nArgo uses DAGs, while Circuit Breaker uses Petri Nets Argo is container-focused, Circuit Breaker is Ruby-native Argo excels at container orchestration, Circuit Breaker at business logic Circuit Breaker provides built-in AI integration Use Cases:\nArgo: Container orchestration, CI/CD pipelines, data processing Circuit Breaker: Agentic AI workflows, Stateful business processes, DevOps pipelines When to Use Circuit Breaker # Circuit Breaker is particularly well-suited for:\nComplex Business Processes\nMultiple states and transitions Complex validation rules State-dependent behavior AI-Powered Workflows\nLLM integration Autonomous agents State-Heavy Applications\nRich state management Complex transition rules Audit requirements Hybrid Workflows\nCombining automated and manual steps Person in the loop pattern Multiple participant roles Complex approval flows Circuit Breaker can also be used effectively for CI/CD and infrastructure management. See CI/CD and Infrastructure for a detailed guide on using Circuit Breaker in DevOps workflows.\n"},{"id":5,"href":"/circuit_breaker/docs/cicd/","title":"CI/CD and Infrastructure","section":"Docs","content":" Using Circuit Breaker for CI/CD and Infrastructure # While traditional CI/CD tools are optimized for linear pipelines, Circuit Breaker\u0026rsquo;s state-based approach offers unique advantages for modern DevOps practices. This guide explores how to leverage Circuit Breaker\u0026rsquo;s capabilities for infrastructure management, CI/CD, and configuration management.\nEnvironment Management # Circuit Breaker can model complex environment lifecycles:\nworkflow = CircuitBreaker::WorkflowDSL.define do states :provisioning, :configuring, :testing, :active, :maintenance, :decommissioning flow(:provisioning \u0026gt;\u0026gt; :configuring) .transition(:provision) .policy(rules: { all: [:infrastructure_ready, :network_configured] }) .actions do execute terraform_executor, :apply, :infrastructure execute kubernetes_executor, :setup_namespace, :namespace end flow(:configuring \u0026gt;\u0026gt; :testing) .transition(:configure) .policy(rules: { all: [:config_valid, :secrets_available] }) .actions do execute config_manager, :apply_configs, :configurations execute vault_executor, :sync_secrets, :secrets end # Environment maintenance flows flow(:active \u0026gt;\u0026gt; :maintenance) .transition(:start_maintenance) .policy(rules: { all: [:maintenance_window_open, :no_active_deployments] }) end Infrastructure as Code Integration # Seamlessly integrate with infrastructure tools:\nclass TerraformExecutor \u0026lt; CircuitBreaker::Executors::BaseExecutor executor_config do parameter :workspace, type: :string, required: true parameter :vars, type: :hash, default: {} before_execute do |context| context.workspace_dir = setup_workspace(context.workspace) end after_execute do |result| cleanup_workspace(result.workspace_dir) end end def execute_internal # Execute Terraform with state management result = apply_terraform(workspace_dir, vars) update_cmdb(result.resources) # Sync with CMDB result end end Configuration Management Database (CMDB) Integration # Track and manage infrastructure state:\nclass CMDBSyncExecutor \u0026lt; CircuitBreaker::Executors::BaseExecutor executor_config do parameter :resource_type, type: :string, required: true parameter :changes, type: :hash, required: true validate do |context| context.changes.valid_schema?(context.resource_type) end end def execute_internal # Sync changes with CMDB cmdb_client.update_resources(resource_type, changes) trigger_dependent_updates(resource_type, changes) end end Release Orchestration # Manage complex release processes:\nworkflow = ReleaseWorkflow.define do states :planning, :building, :testing, :staging, :production, :rollback flow(:building \u0026gt;\u0026gt; :testing) .transition(:build_complete) .policy(rules: { all: [:tests_passed, :security_scan_passed, :artifacts_published] }) .actions do execute artifact_manager, :publish, :artifacts execute security_scanner, :scan, :security_report end flow(:staging \u0026gt;\u0026gt; :production) .transition(:promote) .policy(rules: { all: [ :performance_tests_passed, :approval_obtained, :maintenance_window_open ] }) .actions do execute deployment_executor, :canary_deploy, :deployment execute monitoring_executor, :verify_metrics, :health_check end # Automated rollback capability flow(:production \u0026gt;\u0026gt; :rollback) .transition(:rollback) .policy(rules: { any: [:health_check_failed, :error_threshold_exceeded] }) .actions do execute rollback_executor, :revert_deployment, :rollback_status execute notification_executor, :alert_team, :incident_report end end Benefits for CI/CD # Circuit Breaker offers several advantages for CI/CD:\nState Awareness\nTrack environment state across deployments Maintain configuration versions Handle partial failures gracefully Complex Dependencies\nModel interdependent service deployments Handle cross-environment dependencies Manage configuration relationships Audit and Compliance\nTrack all state changes Maintain deployment history Document approval workflows Intelligent Automation\nAI-powered deployment decisions Automated incident response Smart rollback triggers Integration Patterns # Common integration patterns include:\n1. Environment Lifecycle Management # class EnvironmentManager def initialize(env_name) @workflow = EnvironmentWorkflow.new(env_name) @cmdb = CMDBClient.new end def provision @workflow.provision do |result| @cmdb.register_environment(result.env_details) notify_stakeholders(result.status) end end end 2. Configuration Versioning # class ConfigVersioner def promote_config(config_id) @workflow.promote_config(config_id) do |version| @cmdb.track_config_version(version) trigger_dependent_updates(version) end end end 3. Release Coordination # class ReleaseCoordinator def orchestrate_release(release) @workflow.execute_release(release) do |stage| update_release_status(stage) verify_dependencies(stage) manage_feature_flags(stage) end end end Best Practices # State Management\nKeep environment states clearly defined Use meaningful transition names Implement proper validation rules Track all state changes Infrastructure Integration\nUse idempotent operations Implement proper error handling Maintain state synchronization Version infrastructure changes Release Management\nDefine clear promotion criteria Implement automated validations Set up proper monitoring Plan rollback strategies CMDB Integration\nKeep resource records updated Track configuration versions Maintain dependency graphs Document changes properly This enhanced approach to CI/CD combines the best of traditional tools with Circuit Breaker\u0026rsquo;s state management and AI capabilities, providing a more robust and intelligent deployment pipeline.\n"}]